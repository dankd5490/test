#include <string>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <iomanip>
#include <limits>
#include <vector>

using namespace std;

// Storing Max x and y values for map from file
struct map_size {
    int input_x;
    int input_y;
} map_size;

// Storing details for each grid area within
// 2D array struct
struct grid_area {
    int x, y;
    bool is_occupied;
    int city_id;
    string city_name;
    int cloud, cloud_index, pressure, pressure_index;
    char cloudcover_LMH, pressure_LMH;
};

grid_area **ga;

// Function prototypes
void enter_press();
grid_area process_file();
vector<string> tokenize_string(string, string);
grid_area read_file(string);
grid_area read_file_for_pressure(string);
char get_char(int);
void display_map(int, int);
void display_cloud(int, int);
void display_cloud_LMH(int, int);
void display_pressure(int, int);
void display_pressure_LMH(int, int);
void weather_report(int, int);
int print_city_name(int, int, vector < int > , int);
double get_rain_chance(char, char);
void print_rain_graphic(double);

int main() {
    // Main menu to run constantly until user enters 8
    string choice = "0";

    while (choice != "8") {
        cout << "Welcome to Weather Information Processing System!" << endl;
        cout << "-------------------------------------------------" << endl;

        cout << endl;

        cout << "1)\tRead in and process a configuration file" << endl;
        cout << "2)\tDisplay city map" << endl;
        cout << "3)\tDisplay cloud coverage map (cloudiness index)" << endl;
        cout << "4)\tDisplay cloud coverage map (LMH symbols)" << endl;
        cout << "5)\tDisplay atmospheric pressure map (pressure index)" << endl;
        cout << "6)\tDisplay atmospheric pressure map (LMH symbols)" << endl;
        cout << "7)\tShow forecast summary report" << endl;
        cout << "8)\tQuit" << endl;

        cout << endl;

        cout << "Please enter your choice: ";
        cin >> choice;

        cout << endl;

        if (choice == "1")
            // Process all files
            **ga = process_file();
        else if (choice == "2") {
            // Display city map
            display_map(map_size.input_x, map_size.input_y);
        } else if (choice == "3") {
            // Display cloud index
            display_cloud(map_size.input_x, map_size.input_y);
        } else if (choice == "4") {
            // Display cloud character
            display_cloud_LMH(map_size.input_x, map_size.input_y);
        } else if (choice == "5") {
            // Display pressure index
            display_pressure(map_size.input_x, map_size.input_y);
        } else if (choice == "6") {
            // Display pressure character
            display_pressure_LMH(map_size.input_x, map_size.input_y);
        } else if (choice == "7") {
            // Weather report summary
            weather_report(map_size.input_x, map_size.input_y);
        } else if (choice == "8")
            cout << "Thank you for using this program!" << endl;
        else
            cout << "Please enter valid input" << endl << endl;
    }

    // Deallocate memory for 2D array
    for (int i = 0; i < map_size.input_x + 1; i++) {
        delete[] ga[i];
    }
    delete[] ga;

    return 0;
}

// Allow user to look at functions display before
// moving on by pressing Enter
void enter_press() {
    cout << "Press Enter to Continue: ";
    cin.ignore(std::numeric_limits < streamsize > ::max(), '\n');
    cin.ignore(std::numeric_limits < streamsize > ::max(), '\n');
}

// Begin reading of files
grid_area process_file() {
    string filename;

    // Asking user for input of file name
    cout << "Please enter config filename: ";
    cin >> filename;

    cout << endl;

    // Processing file
    ifstream in_data;

    fstream input_file(filename.c_str(), fstream::in);

    string aline;

    while (getline(input_file, aline)) {
        // Getting range of x if "GridX_IdxRange" is found within line
        if (aline.find("GridX_IdxRange") != string::npos) {
            // Obtain range of numbers into string
            string number_range_str = aline.erase(0, 15); // Remove "GridX_IdxRange" from aline

            // Obtain individual numbers into vector string
            vector<string> number_individual = tokenize_string(number_range_str, "-");

            // Initialize to struct, x variables
            map_size.input_x = atoi(number_individual.at(1).c_str());

            cout << "Reading in " << aline << " ... done!" << endl;
            number_individual.clear();
        }

        // Getting range of y if "GridY_IdxRange" is found within line
        if (aline.find("GridY_IdxRange") != string::npos) {
            // Obtain range of numbers into string
            string number_range_str = aline.erase(0, 15); // Remove "GridY_IdxRange" from aline

            // Obtain individual numbers into vector string
            vector<string> number_individual = tokenize_string(number_range_str, "-");

            // Initialize to struct, y variables
            map_size.input_y = atoi(number_individual.at(1).c_str());

            cout << "Reading in " << aline << " ... done!" << endl;
            number_individual.clear();
        }
        if (map_size.input_x != 0 && map_size.input_y != 0)
            break;
    }

    cout << endl;

    // Allocate array memory in heap
    ga = new grid_area * [map_size.input_x + 1];
    for (int i = 0; i < map_size.input_y + 1; i++)
        ga[i] = new grid_area[map_size.input_y + 1];

    // Putting x and y values into  array
    for (int x_array = 0; x_array < map_size.input_x + 1; x_array++) {
        for (int y_array = 0; y_array < map_size.input_y + 1; y_array++) {
            ga[x_array][y_array].x = x_array;
            ga[x_array][y_array].y = y_array;
        }
    }

    // To decide which file method to use
    int i = 0;

    cout << "Storing data from input file :" << endl;

    // Processing file
    while (getline(input_file, aline)) {
        size_t pos = aline.find(".txt");

        if (pos != string::npos) {
            if (i == 0) {
                // Get city locations into array
                **
                ga = read_file(aline);
                cout << aline << " ... done!" << endl;
            } else if (i == 1) {
                // Get cloud details into array
                **
                ga = read_file(aline);
                cout << aline << " ... done!" << endl;
            } else if (i == 2) {
                // Get pressure details into array
                **
                ga = read_file_for_pressure(aline);
                cout << aline << " ... done!" << endl;
            }
            i++;
        }
    }
    cout << endl;

    cout << "All records successfully stored. Going back to main menu ..." << endl;

    cout << endl;

    return **ga;
}

// Seperate strings into two based on delimiter
vector<string> tokenize_string(string input, string delimiter) {
    size_t pos = 0;
    string token;
    vector<string> result;

    while ((pos = input.find(delimiter)) != string::npos) {
        token = input.substr(0, pos);
        result.push_back(token); // Add element at the end
        input.erase(0, pos + delimiter.length());
    }
    result.push_back(input);

    return (result);
}

// Process file method for reading city and cloud files
grid_area read_file(string filename) {
    fstream input_file(filename.c_str(), fstream::in);

    string aline;
    string next_line;

    while (getline(input_file, aline)) {
        if (aline == "")
            break;

        aline.erase(0, 1); // remove first bracket

        // Obtaining value of grid x
        vector<string> first_value = tokenize_string(aline, ", ");

        int gridX = atoi(first_value.at(0).c_str());

        // Moving on to next part of line
        next_line = first_value[1];

        // Obtaining value of grid y
        vector<string> second_value = tokenize_string(next_line, "]");

        int gridY = atoi(second_value.at(0).c_str());

        // Moving on to next part of line
        next_line = second_value[1];
        next_line = next_line.erase(0, 1); // remove first minus

        if (next_line.size() == 2) {
            // Obtaining value cloud
            int cloud = stoi(next_line);

            // Obtaining value cloud_index
            next_line = next_line.substr(0, 1); // Getting the first digit out of the two
            int cloud_index = stoi(next_line);

            // Obtaining cloudcover character
            char cloudcover_LMH = get_char(cloud);

            // Inserting values into array
            ga[gridX][gridY].cloud = cloud;
            ga[gridX][gridY].cloud_index = cloud_index;
            ga[gridX][gridY].cloudcover_LMH = cloudcover_LMH;
        } else if (next_line.size() == 1) {
            // Obtaining value cloud
            int cloud = stoi(next_line);

            // Obtaining value cloud_index
            int cloud_index = 0;

            // Obtaining cloudcover character
            char cloudcover_LMH = get_char(cloud);

            // Inserting values into array
            ga[gridX][gridY].cloud = cloud;
            ga[gridX][gridY].cloud_index = cloud_index;
            ga[gridX][gridY].cloudcover_LMH = cloudcover_LMH;
        } else {
            vector<string> third_value = tokenize_string(next_line, "-");

            // Obtaining value of ID
            int city_id = atoi(third_value.at(0).c_str());

            // Moving on to next part of line
            next_line = third_value[1];

            // Obtaining city name
            string city_name = next_line;

            // Inserting values into array
            ga[gridX][gridY].city_id = city_id;
            ga[gridX][gridY].is_occupied = true;
            ga[gridX][gridY].city_name = city_name;
        }
    }
    return **ga;
}

// Process file method for pressure file
grid_area read_file_for_pressure(string filename) {
    fstream input_file(filename.c_str(), fstream::in);

    string aline;
    string next_line;

    while (getline(input_file, aline)) {
        if (aline == "")
            break;

        aline.erase(0, 1); // remove first bracket

        // Obtaining value of grid x
        vector<string> first_value = tokenize_string(aline, ", ");

        int gridX = atoi(first_value.at(0).c_str());

        // Moving on to next part of line
        next_line = first_value[1];

        // Obtaining value of grid y
        vector<string> second_value = tokenize_string(next_line, "]");

        int gridY = atoi(second_value.at(0).c_str());

        // Moving on to next part of line
        next_line = second_value[1];
        next_line = next_line.erase(0, 1); // remove first minus

        if (next_line.size() == 2) {
            // Obtaining value cloud
            int pressure = stoi(next_line);

            // Obtaining value cloud_index
            next_line = next_line.substr(0, 1); // Getting the first digit out of the two
            int pressure_index = stoi(next_line);

            // Obtaining cloudcover character
            char pressure_LMH = get_char(pressure);

            // Inserting values into array
            ga[gridX][gridY].pressure = pressure;
            ga[gridX][gridY].pressure_index = pressure_index;
            ga[gridX][gridY].pressure_LMH = pressure_LMH;
        } else {
            // Obtaining value cloud
            int pressure = stoi(next_line);

            // Obtaining value cloud_index
            int pressure_index = 0;

            // Obtaining cloudcover character
            char pressure_LMH = get_char(pressure);

            // Inserting values into array
            ga[gridX][gridY].pressure = pressure;
            ga[gridX][gridY].pressure_index = pressure_index;
            ga[gridX][gridY].pressure_LMH = pressure_LMH;
        }
    }
    return **ga;
}

// Get a character based on number in parameter
char get_char(int cloud_or_pressure) {
    if (cloud_or_pressure < 35)
        return ('L');
    else if (cloud_or_pressure >= 35 && cloud_or_pressure < 65)
        return ('M');
    else
        return ('H');
}

// Constructing the map for city
void display_map(int input_x, int input_y) {
    for (int y = input_y + 1; y >= -2; y--) {
        for (int x = -2; x <= input_x + 1; x++) {
            if ((y == input_y + 1 && x >= -1) || // Print first row of #
                (y == -1 && x >= -1) || // Print last row of #
                (x == -1 && y >= -1) || // Print first column of #
                (x == input_x + 1 && y >= -1)) // Print last column of #
                cout << "# ";
            else if (x == -2 && y >= 0 && y <= input_y) // Print y numbers
                cout << y << " ";
            else if (y == -2 && x >= 0 && x <= input_x) // Print x numbers
                cout << x << " ";
            else if (x <= input_x &&
                x >= 0 &&
                y <= input_y &&
                y >= 0 &&
                ga[x][y].is_occupied == true)
                cout << ga[x][y].city_id << " ";
            else
                cout << "  ";
        }
        cout << endl;
    }
    cout << endl;

    enter_press();

    cout << endl;
}

// Constructing the map for cloud
void display_cloud(int input_x, int input_y) {
    for (int y = input_y + 1; y >= -2; y--) {
        for (int x = -2; x <= input_x + 1; x++) {
            if ((y == input_y + 1 && x >= -1) || // Print first row of #
                (y == -1 && x >= -1) || // Print last row of #
                (x == -1 && y >= -1) || // Print first column of #
                (x == input_x + 1 && y >= -1)) // Print last column of #
                cout << "# ";
            else if (x == -2 && y >= 0 && y <= input_y) // Print y numbers
                cout << y << " ";
            else if (y == -2 && x >= 0 && x <= input_x) // Print x numbers
                cout << x << " ";
            else if (x <= input_x &&
                x >= 0 &&
                y <= input_y &&
                y >= 0)
                cout << ga[x][y].cloud_index << " ";
            else
                cout << "  ";
        }
        cout << endl;
    }
    cout << endl;

    enter_press();

    cout << endl;
}

// Constructing the map for cloud characters
void display_cloud_LMH(int input_x, int input_y) {
    for (int y = input_y + 1; y >= -2; y--) {
        for (int x = -2; x <= input_x + 1; x++) {
            if ((y == input_y + 1 && x >= -1) || // Print first row of #
                (y == -1 && x >= -1) || // Print last row of #
                (x == -1 && y >= -1) || // Print first column of #
                (x == input_x + 1 && y >= -1)) // Print last column of #
                cout << "# ";
            else if (x == -2 && y >= 0 && y <= input_y) // Print y numbers
                cout << y << " ";
            else if (y == -2 && x >= 0 && x <= input_x) // Print x numbers
                cout << x << " ";
            else if (x <= input_x &&
                x >= 0 &&
                y <= input_y &&
                y >= 0)
                cout << ga[x][y].cloudcover_LMH << " ";
            else
                cout << "  ";
        }
        cout << endl;
    }
    cout << endl;

    enter_press();

    cout << endl;
}

// Constructing the map for pressure
void display_pressure(int input_x, int input_y) {
    for (int y = input_y + 1; y >= -2; y--) {
        for (int x = -2; x <= input_x + 1; x++) {
            if ((y == input_y + 1 && x >= -1) || // Print first row of #
                (y == -1 && x >= -1) || // Print last row of #
                (x == -1 && y >= -1) || // Print first column of #
                (x == input_x + 1 && y >= -1)) // Print last column of #
                cout << "# ";
            else if (x == -2 && y >= 0 && y <= input_y) // Print y numbers
                cout << y << " ";
            else if (y == -2 && x >= 0 && x <= input_x) // Print x numbers
                cout << x << " ";
            else if (x <= input_x &&
                x >= 0 &&
                y <= input_y &&
                y >= 0)
                cout << ga[x][y].pressure_index << " ";
            else
                cout << "  ";
        }
        cout << endl;
    }
    cout << endl;

    enter_press();

    cout << endl;
}

// Constructing the map for pressure character
void display_pressure_LMH(int input_x, int input_y) {
    for (int y = input_y + 1; y >= -2; y--) {
        for (int x = -2; x <= input_x + 1; x++) {
            if ((y == input_y + 1 && x >= -1) || // Print first row of #
                (y == -1 && x >= -1) || // Print last row of #
                (x == -1 && y >= -1) || // Print first column of #
                (x == input_x + 1 && y >= -1)) // Print last column of #
                cout << "# ";
            else if (x == -2 && y >= 0 && y <= input_y) // Print y numbers
                cout << y << " ";
            else if (y == -2 && x >= 0 && x <= input_x) // Print x numbers
                cout << x << " ";
            else if (x <= input_x &&
                x >= 0 &&
                y <= input_y &&
                y >= 0)
                cout << ga[x][y].pressure_LMH << " ";
            else
                cout << "  ";
        }
        cout << endl;
    }
    cout << endl;

    enter_press();

    cout << endl;
}

// Creating weather report
void weather_report(int input_x, int input_y) {
    // Print title
    cout << "Weather Forecast Summary Report" << endl;
    cout << "-------------------------------" << endl;

    // Obtaining unique city IDs into int vector
    vector < int > IDs;

    for (int x = 0; x < input_x + 1; x++) {
        for (int y = 0; y < input_y + 1; y++) {
            if (ga[x][y].is_occupied == true)
                IDs.push_back({
                    ga[x][y].city_id
                });
        }
    }

    sort(IDs.begin(), IDs.end());
    IDs.erase(unique(IDs.begin(), IDs.end()), IDs.end());

    // Getting details each city based on ID
    for (unsigned int i = 0; i < IDs.size(); i++) {
        double cloud_area = 0;
        double cloud_total = 0;
        double cloud_average = 0;

        double pressure_area = 0;
        double pressure_total = 0;
        double pressure_average = 0;

        int run_func = print_city_name(input_x, input_y, IDs, i);

        for (int x_array = 0; x_array < input_x + 1; x_array++) {
            for (int y_array = 0; y_array < input_y + 1; y_array++) {
                if (ga[x_array][y_array].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }

                // Attempting to take values around city
                // If city is top of grid
                else if (y_array + 1 <= input_y && ga[x_array][y_array + 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is top left of grid
                else if (y_array + 1 <= input_y && x_array - 1 <= input_x && x_array - 1 >= 0 && ga[x_array - 1][y_array + 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is top right of grid
                else if (y_array + 1 <= input_y && x_array + 1 <= input_x && ga[x_array + 1][y_array + 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is left of grid
                else if (x_array - 1 <= input_x && x_array - 1 >= 0 && ga[x_array - 1][y_array].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is right of grid
                else if (x_array + 1 <= input_x && ga[x_array + 1][y_array].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is bottom of grid
                else if (y_array - 1 <= input_y && y_array - 1 >= 0 && ga[x_array][y_array - 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is bottom left of grid
                else if (y_array - 1 <= input_y && y_array - 1 >= 0 && x_array - 1 <= input_x && x_array - 1 >= 0 && ga[x_array - 1][y_array - 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
                // If city is bottom right of grid
                else if (y_array - 1 <= input_y && y_array - 1 >= 0 && x_array + 1 <= input_x && ga[x_array + 1][y_array - 1].city_id == IDs[i]) {
                    cloud_area++;
                    cloud_total += ga[x_array][y_array].cloud;

                    pressure_area++;
                    pressure_total += ga[x_array][y_array].pressure;
                }
            }
        }
        // Calculate average of cloud and pressure
        cloud_average = cloud_total / cloud_area;
        pressure_average = pressure_total / pressure_area;

        cout << "City ID   : " << IDs[i] << endl;
        cout << "Ave. Cloud  Cover (ACC)   : " << fixed << setprecision(2) << cloud_average <<
            " (" << get_char((int) cloud_average) << ")" << endl;
        cout << "Ave. Pressure     (AP)    : " << fixed << setprecision(2) << pressure_average <<
            " (" << get_char((int) pressure_average) << ")" << endl;

        // Get rain probability based on characters from average
        double rain_chance = get_rain_chance(get_char((int) cloud_average), get_char((int) pressure_average));

        cout << "Probability of Rain (%)   : " << fixed << setprecision(2) << rain_chance << endl;

        // Print rain graphic
        print_rain_graphic(rain_chance);

        cout << endl;
    }
    enter_press();

    cout << endl;
}

// Print unique city name once during report
int print_city_name(int input_x, int input_y, vector < int > IDs, int i) {
    for (int x_array = 0; x_array < input_x + 1; x_array++) {
        for (int y_array = 0; y_array < input_y + 1; y_array++) {
            if (ga[x_array][y_array].city_id == IDs[i]) {
                cout << "City Name : " << ga[x_array][y_array].city_name << endl;

                return (0);
            }
        }
    }
    return (0);
}

// Get double based on characters in parameters
double get_rain_chance(char cloud_average, char pressure_average) {
    if (cloud_average == 'H' && pressure_average == 'L')
        return (90);
    else if (cloud_average == 'M' && pressure_average == 'L')
        return (80);
    else if (cloud_average == 'L' && pressure_average == 'L')
        return (70);
    else if (cloud_average == 'H' && pressure_average == 'M')
        return (60);
    else if (cloud_average == 'M' && pressure_average == 'M')
        return (50);
    else if (cloud_average == 'L' && pressure_average == 'M')
        return (40);
    else if (cloud_average == 'H' && pressure_average == 'H')
        return (30);
    else if (cloud_average == 'M' && pressure_average == 'H')
        return (20);
    else
        return (10);
}

// Print graphic on rain based on double 
void print_rain_graphic(double rain_chance) {
    if (rain_chance == 90) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
        cout << "\\\\\\\\\\" << endl;
    } else if (rain_chance == 80) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
        cout << " \\\\\\\\" << endl;
    } else if (rain_chance == 70) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
        cout << "  \\\\\\" << endl;
    } else if (rain_chance == 60) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
        cout << "   \\\\" << endl;
    } else if (rain_chance == 50) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
        cout << "    \\" << endl;
    } else if (rain_chance == 40) {
        cout << "~~~~" << endl;
        cout << "~~~~~" << endl;
    } else if (rain_chance == 30) {
        cout << "~~~" << endl;
        cout << "~~~~" << endl;
    } else if (rain_chance == 20) {
        cout << "~~" << endl;
        cout << "~~~" << endl;
    } else {
        cout << "~" << endl;
        cout << "~~" << endl;
    }
}
